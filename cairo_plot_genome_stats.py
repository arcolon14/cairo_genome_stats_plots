#!/usr/bin/env python3
import sys, os, math, argparse, datetime
import cairo
import numpy as np
# from IPython.display import SVG, display, Image

# Some constants
PROG = sys.argv[0].split('/')[-1]
MIN_CHR_LEN = 1_000_000
SCALE = 1_000_000
STEP = 5_000_000
IMG_WIDTH = 500
IMG_HEIGHT = 500

#
# Command line options
#
def parse_args():
    p = argparse.ArgumentParser()
    p.add_argument('-f', '--fai', required=True,
                   help='(str) Path to genome index in FAI format.')
    p.add_argument('-t', '--in-table', required=True, 
                   help='(str) Path to input table of window statistics, generated by `bin_genome_stats.py`.')
    # Optional Parameters
    p.add_argument('-c', '--chroms', required=False, default=None,
                   help='(str) Path to chromosome order list [default=None].')
    p.add_argument('-o', '--out-dir', required=False, default='.', 
                   help='(str) Path to output directory [default=.].')
    p.add_argument('-n', '--basename', required=False, default=None,
                   help='(str) Basename of output files [default=In table basename].')
    p.add_argument('-m', '--min-len', required=False, default=MIN_CHR_LEN,
                   type=float, help=f'(int/float) Minimum chromosome size in bp [default {MIN_CHR_LEN:,}]')
    p.add_argument('-s', '--scale', required=False, default=SCALE, type=float,
                   help=f'(int/float) Scale chromosome lengths to this value [default={SCALE:,}],')
    p.add_argument('-p', '--step', required=False, default=STEP, type=float,
                   help=f'(int/float) Steps for size for axis tick marks [default={STEP:,}].')
    p.add_argument('--img-height', required=False, default=IMG_HEIGHT, type=int,
                   help=f'(int) Image height in pixels [default={IMG_HEIGHT}].')
    p.add_argument('--img-width', required=False, default=IMG_WIDTH, type=int,
                   help=f'(int) Image width in pixels [default={IMG_WIDTH}].')
    p.add_argument('--img-format', required=False, default='pdf',
                   help='(str) Image output format [default=pdf]')
    # Check inputs
    args = p.parse_args()
    assert args.scale <= args.min_len
    if args.chroms is not None:
        assert os.path.exists(args.chroms)
    assert os.path.exists(args.fai)
    assert os.path.exists(args.in_table)
    assert os.path.exists(args.out_dir)
    assert args.img_format in ['pdf', 'svg']
    args.out_dir = args.out_dir.rstrip('/')
    # Adjust the basename if missing
    if args.basename is None:
        args.basename = args.in_table.split('/')[-1][:-len('.binned_genome_stats.tsv')]
    # Standarize the sizes to integers
    args.scale = int(args.scale)
    args.step = int(args.step)
    args.min_len = int(args.min_len)
    return args

# Load the chromosome order list
def read_chromosomes(chrom_f):
    os.path.exists(chrom_f)
    chrom_order = list()
    for line in open(chrom_f, 'r'):
        if line.startswith('#'):
            continue
        chrom = line.strip('\n').split('\t')
        assert len(chrom) == 1
        chrom_order.append(chrom[0])
    print(f'    Read {len(chrom_order):,} records from chromosome order list.', flush=True)
    return chrom_order

#
# Load Fasta index
#

## Chromosome class
class Chromosome:
    def __init__(self, name, length):
        assert type(length) is int
        self.name = name
        self.len  = length
    def __str__(self):
        return f'{self.name} {self.len}'

def load_fai(fai_f, min_len=MIN_CHR_LEN):
    assert os.path.exists(fai_f)
    ## Loop over FAI and extract
    chromosomes = dict()
    n = 0
    assert os.path.exists(fai_f), f'Error: {fai_f} not found.'
    for line in open(fai_f, 'r'):
        if line.startswith('#'):
            continue
        n += 1
        fields = line.strip('\n').split('\t')
        name = fields[0]
        length = int(fields[1])
        if length < min_len:
            continue
        chrom = Chromosome(name, length)
        chromosomes[name] = chrom
    # Report FAI
    print(f'\nRead {n:,} records from the FAI file.\n    Kept {len(chromosomes):,} entries with lengths larger than {min_len:,}', flush=True)
    return chromosomes


def process_chromosome_info(fai_f, chrom_order_f, min_len=MIN_CHR_LEN):
    '''
    Process all chromosome info including FAI and order file.
    '''
    # First, load the FASTA index
    fai = load_fai(fai_f, min_len)
    # If there is no chromosome order provided, use the FAI
    chrom_order = None
    if chrom_order_f is None:
        chrom_order = fai.keys()
    else:
        # Otherwise, read the chromosome order
        chrom_order = read_chromosomes(chrom_order_f)
    # Filter the FAI to just keep those entries
    fai_bak = fai
    fai = dict()
    for chrom in chrom_order:
        chromosome = fai_bak.get(chrom, None)
        if chromosome is None:
            sys.exit(f"Error: {chrom} not found in FAI entries larger than {min_len:,}.")
        assert isinstance(chromosome, Chromosome)
        fai[chrom] = chromosome
    # Report to log
    print(f'    Kept {len(fai):,} chromosome objects after filtering.', flush=True)
    return fai, chrom_order


#
# Load the window proportions file
#

## Window statistic class
class WindowStat:
    def __init__(self, chromosome, start, end, mid,
                 n_elements=0.0, proportion=0.0):
        assert type(start) in [int, float]
        assert type(end) in [int, float]
        assert type(mid) in [int, float]
        assert type(n_elements) is float
        assert type(proportion) is float
        self.chr = chromosome
        self.start = start
        self.end = end
        self.mid = mid
        self.n_elements = n_elements
        self.proportion = proportion
    def __str__(self):
        return f'{self.chr} {self.start} {self.end} {self.mid} {self.n_elements} {self.proportion}'


def load_window_stats_file(win_f, chromosomes):
    '''
    Parse the input window stats file, generated by the 
    `bin_genome_stats.py` script.
    '''
    assert os.path.exists(win_f)
    assert type(chromosomes) is dict
    assert isinstance(list(chromosomes.values())[0], Chromosome)

    ## Initialize the output dictionary based on the read chromosomes
    print(f'\nReading the input windows file:\n    {win_f}', flush=True)
    wins_dict = { chrom : [] for chrom in chromosomes }
    elements_vals = list()
    proportion_vals = list()
    records = 0
    kept = 0

    # The columns for the input file are:
    #    0: Chrom
    #    1: StartBP
    #    2: EndBP
    #    3: MidBP
    #    4: ElementsN
    #    5: ElementsAdj
    #    6: PropSites
    #    7: PropSitesAdj

    # Parse the input windows file
    with open(win_f) as fh:
        for line in fh:
            if line.startswith('#'):
                continue
            records += 1
            fields = line.strip('\n').split('\t')
            chrom = fields[0]
            if chrom not in wins_dict:
                continue
            start = float(fields[1])
            end = float(fields[2])
            mid = float(fields[3])
            n_elements = float(fields[5])
            proportion = float(fields[7])
            # Make the class for the window
            window_stat = WindowStat(chrom, start, end, mid, n_elements, proportion)
            wins_dict[chrom].append(window_stat)
            kept += 1
            # Append to the list of elements to get the max values
            elements_vals.append(n_elements)
            proportion_vals.append(proportion)
    # Find the max values
    max_elements = max(elements_vals)
    max_proportion = max(proportion_vals)
    # Report to logs
    print(f'    Read {records:,} records from the input windows table.\n    Retained {kept:,} records.', flush=True)
    return wins_dict, max_elements, max_proportion

#
# Colors for the chromosome elements
# This includes chromosome lines, tick marks, and labels
class ChromColors:
    def __init__(self, item):
        cols_chrom = {
            'ticks'  : [192.0/255.0, 192.0/255.0, 192.0/255.0],
            'fill'   : [127.0/255.0, 127.0/255.0, 127.0/255.0],
            'line'   : [125.0/255.0, 125.0/255.0, 125.0/255.0],
            'text'   : [ 25.0/255.0,  25.0/255.0,  25.0/255.0],
            'border' : [ 50.0/255.0,  50.0/255.0,  50.0/255.0]
        }
        color  = cols_chrom[item]
        self.r = color[0]
        self.g = color[1]
        self.b = color[2]
        self.a = 1
    def __str__(self):
        return f'R: {self.r:.2f}, G: {self.g:.2f}, B: {self.b:.2f}, A: {self.a:.2f}'


# Other colors
# check https://www.colorhexa.com/

# TODO: Set these as a command line option
colors = []
# colors.append((  0.0/255.0,  80.0/255.0, 242.0/255.0)) # 0050f2 Blue
# colors.append((255.0/255.0, 255.0/255.0, 255.0/255.0)) # ffffff White
# colors.append((255.0/255.0,   0.0/255.0,   0.0/255.0)) # ff0000 Red

# # Viridis
# colors.append(( 25.0/255.0,  25.0/255.0, 112.0/255.0)) # #191970 Indigo
# colors.append((  0.0/255.0, 105.0/255.0, 062.0/255.0)) # #00693e Green
# colors.append((255.0/255.0, 168.0/255.0,  18.0/255.0)) # #ffa812 Yellow

# Mango
# colors.append((  0.0/255.0, 105.0/255.0, 062.0/255.0)) # #00693e Green
# colors.append((255.0/255.0, 168.0/255.0,  18.0/255.0)) # #ffa812 Yellow
# colors.append((178.0/255.0,  34.0/255.0,  34.0/255.0)) # #ff0000 Red

# Mango Light
# colors.append(( 68.0/255.0, 157.0/255.0,  72.0/255.0)) # #449D48 Green
# colors.append((246.0/255.0, 219.0/255.0, 106.0/255.0)) # #F6DB6A Yellow
# colors.append((229.0/255.0,  68.0/255.0,  73.0/255.0)) # #e54449 Red

# Magma
# colors.append((  0.0/255.0,   0.0/255.0, 139.0/255.0)) # #191970 Indigo
# colors.append((255.0/255.0,  40.0/255.0,   0.0/255.0)) # ff0000 Red
# colors.append((252.0/255.0, 247.0/255.0,  94.0/255.0)) # #ffa812 Yellow

# RedYellowBlue
colors.append((  0.0/255.0,  80.0/255.0, 242.0/255.0)) # 0050f2 Blue
colors.append((252.0/255.0, 247.0/255.0,  94.0/255.0)) # #ffa812 Yellow
colors.append((255.0/255.0,   0.0/255.0,   0.0/255.0)) # ff0000 Red


def scale_sigmoid_color_mean(mean, val):
    '''
    Plot the values using a Gompertz curve: y(t) = ae^(-be(^-ct))
      https://en.wikipedia.org/wiki/Gompertz_function
    The X-axis scales from 0 to 10, Y-axis from 0 to 1; we have shifted
    the curve to the right by subtracting 2 from val; we will shit it 
    more to line the sigmoid curve up with the mean value.
    '''
    val  = math.fabs(val)
    val  = val * 10
    mean = mean * 10 / 2
    a    = 1
    b    = 1
    c    = 0.5
    val  = a * math.exp(-1 * b * (math.exp(-1 * c * (val - 2 - mean))))
    return val

def three_color_gradient(rgb1, rgb2, rgb3, mean, alpha, max_scale):
    (r1, g1, b1) = rgb1
    (r2, g2, b2) = rgb2
    (r3, g3, b3) = rgb3

    # Adjust mean and alpha so that max value is 1.0
    adj_mean = mean/max_scale
    adj_alpha = alpha/max_scale
    adj_alpha = scale_sigmoid_color_mean(adj_mean, adj_alpha)
    # scaled_alpha = float(alpha)
    if (adj_alpha < adj_mean):
        # scaled_alpha = float(alpha) / mean
        scaled_alpha = float(adj_alpha) / adj_mean
        r = ((1.0 - scaled_alpha) * r1) + (scaled_alpha * r2)
        g = ((1.0 - scaled_alpha) * g1) + (scaled_alpha * g2)
        b = ((1.0 - scaled_alpha) * b1) + (scaled_alpha * b2)
    else:
        # scaled_alpha = float(alpha - mean) / (1.0 - mean)
        scaled_alpha = float(adj_alpha - adj_mean) / (1.0 - adj_mean)
        r = (scaled_alpha * r3) + ((1.0 - scaled_alpha) * r2)
        g = (scaled_alpha * g3) + ((1.0 - scaled_alpha) * g2)
        b = (scaled_alpha * b3) + ((1.0 - scaled_alpha) * b2)
    return (r, g, b)

# Set PyCairo environment
#
# Class to set the settings to the image output
class Image:
    def __init__(self, height=500, width=500, font_size=18, img_type='pdf', offset=25, edge=15):
        assert offset > edge
        # General Plot info
        self.height = height
        self.width  = width
        self.font   = font_size
        self.type   = img_type
        self.max_y  = edge
        self.min_y  = height-edge
        self.min_x  = edge
        self.max_x  = width-edge
        # Position for the objects
        self.min_chr = offset
        self.max_chr = self.max_x
        self.min_tck = self.max_y
        self.max_tck = height-offset
        # Position for labels
        self.len_lab = height-edge
        self.chr_lab = offset-edge
    def scale_bp_to_pix(self, pos_bp, max_bp):
        scaled_x = ((pos_bp/max_bp)*(self.max_chr - self.min_chr)) + self.min_chr
        return scaled_x
    def cairo_context(self, plot_out_dir):
        if self.type == 'pdf':
            surface = cairo.PDFSurface(plot_out_dir, self.width, self.height)
            context = cairo.Context(surface)
            return surface, context
        elif self.type == 'svg':
            surface = cairo.SVGSurface(plot_out_dir, self.width, self.height)
            context = cairo.Context(surface)
            return surface, context
        else:
            sys.exit("The only supported formats are \'PDF\' and \'SVG\'.")


#
# Plot gridlines
#
def plot_gridlines(chromosomes, image, context, scale=SCALE, step=STEP):
    assert type(chromosomes) is dict
    assert isinstance(list(chromosomes.values())[0], Chromosome)
    assert isinstance(image, Image)
    # Plot the gridlines
    max_bp = max([ chromosomes[chrom].len for chrom in chromosomes ])
    assert max_bp > step
    grid = list(range(0,(max_bp+step),step))
    max_grd = max(grid)
    for bp in grid:
        # Add gridlines
        y1 = image.min_tck
        y2 = image.max_tck+(image.max_y/4)
        x = image.scale_bp_to_pix(bp, max_grd)
        context.set_dash([6.0, 3.0])
        context.set_line_cap(cairo.LINE_CAP_BUTT)
        context.move_to(x, y1)
        context.line_to(x, y2)
        ticks_col = ChromColors('ticks')
        context.set_source_rgb(ticks_col.r, ticks_col.g, ticks_col.b)
        context.set_line_width(0.75)
        context.stroke()
        # Add labels
        label = f'{int(bp//scale)}M'
        label_height = context.text_extents(label)[3]
        label_width  = context.text_extents(label)[2]
        txt_col = ChromColors('text')
        lab_x = x-(label_width/2)
        lab_y = image.len_lab+(label_height)
        context.move_to(lab_x, lab_y)
        context.set_source_rgb(txt_col.r, txt_col.g, txt_col.b)
        context.show_text(label)
    return max_grd

#
# Process the chromosomes
#
def process_chromosomes(chromosomes, chrom_order, wins_dict, image, context, max_grd, mean_reps, max_reps, scale=SCALE, step=STEP):
    assert type(chromosomes) is dict
    assert isinstance(list(chromosomes.values())[0], Chromosome)
    assert type(wins_dict) is dict
    assert isinstance(image, Image)
    assert len(chromosomes) == len(chrom_order)

    # Plot the chromosomes and values
    chr_step = (image.max_tck-image.min_tck)/len(chromosomes)
    min_step = chr_step/4
    y = image.min_tck

    ## Loop over the chromosomes
    # for chromosome in sorted(chromosomes, key=lambda c: chromosomes[c].len, reverse=True):
    for chromosome in chrom_order:
        assert chromosome in chromosomes
        # Define the boundaries of the chromosome
        bp = chromosomes[chromosome].len
        x1 = image.min_chr
        x2 = image.scale_bp_to_pix(bp, max_grd)
        y1 = y+(1*min_step)
        y2 = y+(3*min_step)

        # # Extract the windows for the current chromosome
        # windows = wins_dict.get(chromosome, [])
        # if len(windows) > 0:
        #     for window in windows:
        #         assert isinstance(window, WindowStat)
        #         if window.bp > bp:
        #             continue
        #         x = image.scale_bp_to_pix(window.bp, max_grd)
        #         (r, g, b) = three_color_gradient(colors[0], colors[1], colors[2], mean_reps,
        #                                          window.val, max_reps)
        #         context.set_dash([])
        #         context.move_to(x, y1)
        #         context.line_to(x, y2)
        #         context.set_source_rgb(r, g, b)
        #         context.stroke()

        # Add the Chromosome len boxes
        context.set_dash([])
        context.move_to(x1, y1)
        context.line_to(x2, y1)
        context.line_to(x2, y2)
        context.line_to(x1, y2)
        context.close_path()
        context.set_line_width(1.0)
        col = ChromColors('border')
        context.set_source_rgb(col.r, col.g, col.b)
        # context.stroke_preserve()
        context.stroke()
        # col = ChromColors('fill')
        # context.set_source_rgb(col.r, col.g, col.b)
        # context.fill()

        # Add the labels
        label = str(chromosomes[chromosome].name)
        label_height = context.text_extents(label)[3]
        label_width  = context.text_extents(label)[2]
        lab_x = image.chr_lab-(label_width/2)
        lab_y = (y+(2*min_step))+(label_height/2)
        txt_col = ChromColors('text')
        context.move_to(lab_x, lab_y)
        context.set_source_rgb(txt_col.r, txt_col.g, txt_col.b)
        context.show_text(label)
        y += chr_step

#
# Draw the Scale
#
def draw_scale(image, context, mean_reps, max_reps):
    assert isinstance(image, Image)
    # Boundaries
    x1 = image.max_x*0.945
    x2 = image.max_x*0.995
    y1 = image.max_tck*0.795
    y2 = image.max_tck*0.995
    # Loop over the color space
    s=0.005
    for p in np.arange(0,(max_reps+s),s):
        (r, g, b) = three_color_gradient(colors[0], colors[1], colors[2], mean_reps, p, max_reps)
        key_h = y2-y1
        yp = y2-(key_h*(p/max_reps))
        context.set_dash([])
        context.move_to(x1, yp)
        context.line_to(x2, yp)
        context.set_source_rgb(r, g, b)
        context.stroke()
    # Outer box
    context.set_dash([])
    context.move_to(x1, y1)
    context.line_to(x2, y1)
    context.line_to(x2, y2)
    context.line_to(x1, y2)
    context.close_path()
    context.set_line_width(1.0)
    col = ChromColors('border')
    context.set_source_rgb(col.r, col.g, col.b)
    # context.stroke_preserve()
    context.stroke()
    # col = ChromColors('fill')
    # context.set_source_rgb(col.r, col.g, col.b)
    # context.fill()

    #
    # Add labels
    #
    # Top Label
    # lab1 = f'{float(round(max_reps+s))}'
    lab1 = f'{round(max_reps+s)}x'
    label_height = context.text_extents(lab1)[3]
    label_width  = context.text_extents(lab1)[2]
    lab_x = x1-(label_width*1.25)
    lab_y = y1+(label_height/2)
    txt_col = ChromColors('text')
    context.move_to(lab_x, lab_y)
    context.set_source_rgb(txt_col.r, txt_col.g, txt_col.b)
    context.show_text(lab1)
    # Bottom Label
    # lab2 = f'{0.0}x'
    lab2 = '0x'
    label_height = context.text_extents(lab2)[3]
    label_width  = context.text_extents(lab2)[2]
    lab_x = x1-(label_width*1.25)
    lab_y = y2+(label_height/2)
    txt_col = ChromColors('text')
    context.move_to(lab_x, lab_y)
    context.set_source_rgb(txt_col.r, txt_col.g, txt_col.b)
    context.show_text(lab2)
    # Middle label
    # labm = f'{1.0}x'
    labm = f'1x'
    label_height = context.text_extents(labm)[3]
    label_width  = context.text_extents(labm)[2]
    # TODO: 
    # lab_x = x1-(label_width*1.25)
    key_h = y2-y1
    lab_y = y2-(key_h*(mean_reps/max_reps))+(label_height/2)
    # lab_y = y1+(label_height/2)
    txt_col = ChromColors('text')
    context.move_to(lab_x, lab_y)
    context.set_source_rgb(txt_col.r, txt_col.g, txt_col.b)
    context.show_text(labm)

# Add title to the figure
def draw_title(image, context, title):
    assert isinstance(image, Image)
    x = image.min_chr
    y = image.max_y
    # Adjust height
    title_height = context.text_extents(title)[3]
    y = y-(title_height/2)
    txt_col = ChromColors('text')
    context.move_to(x,y)
    context.set_source_rgb(txt_col.r, txt_col.g, txt_col.b)
    context.show_text(title)


# Draw a figure
def draw_genome_stats(outf, chromosomes, chrom_order, win_val_dict, 
                      mean_val, max_val, name,
                      height=IMG_HEIGHT, width=IMG_WIDTH, 
                      scale=SCALE, step=STEP, img_type='pdf'):
    print(f'\nMaking plot ({name}):\n    {outf}', flush=True)
    # Set an image object global variable
    image = Image(height=height, width=width, img_type=img_type)
    surface, context = image.cairo_context(outf)
    # Plot gridlines
    max_grd = plot_gridlines(chromosomes, image, context, scale, step)
    # Process the chromosomes
    process_chromosomes(chromosomes, chrom_order, win_val_dict, 
                        image, context, max_grd, mean_val, 
                        max_val, scale, step)
    # Plot the scale
    draw_scale(image, context, mean_val, max_val)
    # Add title
    draw_title(image, context, name)


def date():
    '''Print the current date in YYYY-MM-DD format.'''
    return datetime.datetime.now().strftime("%Y-%m-%d")

def time():
    '''Print the current time in HH:MM:SS format.'''
    return datetime.datetime.now().strftime("%H:%M:%S")


def main():
    print(f'{PROG} started on {date()} {time()}.')
    args = parse_args()
    print(f'    Min Chrom Length: {int(args.min_len):,} bp')

    # Load chromosome information
    chromosomes, chrom_order = process_chromosome_info(args.fai, args.chroms, args.min_len)

    # Get Max Chr size
    max_bp = max([ chromosomes[chrom].len for chrom in chromosomes ])

    # Load the target genetic elements
    windows, max_elements, max_proportion = load_window_stats_file(args.in_table, chromosomes)

    # Plot the genome stats

    # 1. For the number of elements
    outf = f'{args.out_dir}/{args.basename}.num_elements.{args.img_format}'
    name = f'{args.basename} : Number of elements per window'
    draw_genome_stats(outf, chromosomes, chrom_order, 
                      windows, 1.0, max_elements, name,
                      height=args.img_height, width=args.img_width, scale=args.scale, step=args.step, 
                      img_type=args.img_format)


    print(f'\n{PROG} finished on {date()} {time()}.')

# Run Code
if __name__ == '__main__':
    main()
